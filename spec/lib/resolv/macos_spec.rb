require 'rspec'

RSpec.describe Dory::Resolv::Macos do
  let(:resolv_dir) { '/tmp/resolver' }
  let(:resolv_files) { %w[docker dev dory] }
  let(:system_resolv_file) { '/tmp/resolv.conf' }
  let(:filenames) { %w[/tmp/resolver/docker /tmp/resolver/dev /tmp/resolver/dory] }

  let(:ubuntu_resolv_file_contents) do
    %q(
      # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
      #     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
      nameserver 10.0.34.17
      nameserver 10.0.34.16
      nameserver 10.0.201.16
      search corp.instructure.com
    ).split("\n").map{|s| s.gsub(/^\s+/, '')}.join("\n")
  end

  let(:stub_resolv_file) do
    ->() do
      allow(Dory::Resolv::Macos).to receive(:resolv_dir) { resolv_dir }
      allow(Dory::Resolv::Macos).to receive(:resolv_file_names) { resolv_files }
      allow(Dory::Resolv::Macos).to receive(:system_resolv_file) { system_resolv_file }
      # make sure we aren't going to over-write the real resolv file
      expect(Dory::Resolv::Macos.resolv_files).to eq(filenames)
      expect(Dory::Resolv::Macos.system_resolv_file).to eq(system_resolv_file)
    end
  end

  let(:set_macos) do
    ->() do
      allow(Dory::Os).to receive(:macos?){ true }
      allow(Dory::Os).to receive(:ubuntu?){ false }
      allow(Dory::Os).to receive(:fedora?){ false }
      allow(Dory::Os).to receive(:arch?){ false }
    end
  end

  context 'settings' do
    context 'resolv' do
      let(:default_port) { 19323 }
      let(:specified_port) { 9999 }
      let(:explicit_port) {{ dory: { resolv: { port: specified_port }}}}
      let(:implicit_port) {{ dory: { resolv: {}}}}

      it 'has a default port if one is not specified' do
        allow(Dory::Config).to receive(:settings) { explicit_port }
        expect(Dory::Resolv::Macos.port).to eq(specified_port)
      end

      it "let's you specify a port" do
        allow(Dory::Config).to receive(:settings) { implicit_port }
        expect(Dory::Resolv::Macos.port).to eq(default_port)
      end
    end

    context 'dnsmasq' do
      let(:domains) { %w[docker dev dory somethingelse] }
      let(:domains_settings) {{ dory: { dnsmasq: {
        domains: domains.map{|d| { domain: d, address: '127.0.0.1' } }
      }}}}

      it 'has a filename for each domain' do
        allow(Dory::Config).to receive(:settings) { domains_settings }
        expect(Dory::Resolv::Macos.resolv_file_names).to match_array(domains)
        expect(Dory::Resolv::Macos.resolv_files).to match_array(
          domains.map{|d| "#{Dory::Resolv::Macos.resolv_dir}/#{d}" }
        )
      end
    end
  end

  context "creating and deleting the file" do
    before :each do
      stub_resolv_file.call()
      # To add an extra layer of protection against modifying the
      # real resolv file, make sure it matches
      expect(Dory::Resolv::Macos.resolv_files).to match_array(filenames)
      filenames.each do |filename|
        if File.exists?(filename)
          puts "Requesting sudo to delete #{filename}".green
          Dory::Bash.run_command("sudo rm -f #{filename}")
        end
        expect(File.exists?(filename)).to be_falsey
      end
    end

    it 'creates the directory if it doesn\'t exist' do
      puts "Requesting sudo to delete #{resolv_dir}".green
      Dory::Bash.run_command("sudo rm -rf #{resolv_dir}")
      expect{Dory::Resolv::Macos.configure}.to change{Dir.exists?(resolv_dir)}.from(false).to(true)
    end

    it "creates the files with the nameserver in it" do
      expect(filenames.all?{|f| !File.exists?(f)}).to be_truthy
      Dory::Resolv::Macos.configure
      expect(filenames.all? do |f|
        File.exists?(f) && File.read(f) =~ /added.by.dory/
      end).to be_truthy
    end

    it "cleans up properly" do
      filenames.each do |filename|
        expect{Dory::Resolv::Macos.configure}.to change{
          File.exists?(filename)
        }.from(false).to(true)
        expect{Dory::Resolv::Macos.clean}.to change{
          File.exists?(filename)
        }.from(true).to(false)
      end
    end
  end

  context "Seeing system settings" do
    it "knows if we are in the resolv file" do
      # TODO check to see if the changes we wrote to the resolv file
      # were propagated into the system resolv file
    end

    it "knows if we are not in the resolv file" do

    end
  end

  context "knows if we've edited the file" do
    let (:comment) { '# added by dory' }

    let (:stub_resolv) do
      ->(nameserver, file_comment = comment) do
        allow(Dory::Resolv).to receive(:nameserver){ nameserver }
        allow(Dory::Resolv).to receive(:file_comment){ comment }
        expect(Dory::Resolv.nameserver).to eq(nameserver)
        expect(Dory::Resolv.file_comment).to eq(comment)
      end
    end

    %w[127.0.0.1 192.168.53.164].each do |nameserver|
      # Note:  This addresses a bug encountered on Fedora 23 Cloud
      it "doesn't think we edited the file if 127.0.0.1 is there but the comment isn't" do
        stub_resolv.call(nameserver)
        contents = "nameserver 1.1.1.1\nnameserver #{nameserver}\nnameserver 2.2.2.2"
        expect(Dory::Resolv.contents_has_our_nameserver?(contents)).to be_falsey
      end

      it "does think we edited the file if 127.0.0.1 is there but the comment isn't" do
        stub_resolv.call(nameserver)
        contents = "nameserver 1.1.1.1\n#{comment}\nnameserver #{nameserver}\nnameserver 2.2.2.2"
        expect(Dory::Resolv.contents_has_our_nameserver?(contents)).to be_truthy
      end
    end
  end
end
